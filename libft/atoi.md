## О поведении “стандартных оригинальных” функций и ретивых проверяющих. [RU]

### Author: [@jbelinda](https://profile.intra.42.fr/users/jbelinda)

### [Original](https://forum.intra.42.fr/topics/21586/messages)

Текст обращён в первую очередь к тем “пирам”, которые любят “зарубить” корректный и работающий код по той причине, что реализованная студентом функция работает не так, как “стандартная оригинальная” функция. Для примера я взял особо полюбившуюся вам ```int ft_atoi(const char *s)```.

А вы считаете, что того, чего не показали по телевизору, не существует? Нет, не считаете? Это очень хорошо, ещё не всё потеряно. Но почему вы тогда убеждены, что того, чего нет у вас на компьютере, не существует? А если и существует, то оно глючное, кривое, нестандартное и ни разу не оригинальное?

Давайте-ка посмотрим на пару скриншотов. Реальные, свежие, не Photoshop, легко можете проверить сами.

![FreeBSD/clang8](https://i.imgur.com/obOei1S.png)

![Windows/Visual Studio Community 2019](https://i.imgur.com/upo5tPY.png)

Исходный код:
```C
#include <stdio.h>
#include <stdlib.h>

&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
printf("sizeof(int) = %d\n", (int)sizeof(int));
printf("atoi(\"9988776655443322110\") = %d\n", atoi("9988776655443322110"));
return (0);
}
```

Обе системы 64-битные, оба компилятора имеют огромную аудиторию, переварили уже дофигалиарды строк кода, на одном используется libc от Microsoft, на другом — The Regents of the University of California *(возможно, она же используется в OSX, но не факт)*. Но почему разный результат?! Кто тут “кривой”?

Этот вопрос не вам, можете не отвечать. Ответьте лучше на этот — а что такое эти ваши “стандартные оригинальные” функции? Где можно посмотреть их исходный код? Да пусть даже не исходный, где их можно взять на поюзать?

А теперь — суровая правда жизни. Для начала усвойте одну очень простую истину — **никаких стандартных оригинальных функций в виде кода (хоть исходного, хоть объектного) не существует в природе**. Точка. На этом можно было бы и закончить, но я ещё чуть порастекаюсь мыслью по древу...

Стандартных (в вашем понимании этого слова) функций вероятнее всего никогда и не появится. В виде кода. Это просто никому не нужно — один единственно верный код для всех. Хотя бы потому, что код, эффективный на одной платформе, может оказаться довольно тормозным на другой. Поэтому понимайте словосочетание “стандартная функция” как “**функция, обязательная для соответствующей стандарту** ISO/IEC 9899 реализации языка программирования C” и никак иначе.

Что до оригинальности, то каждый из вас свою уже создал, похоже. Не думаю, что вашу оригинальность когда-нибудь при вашей жизни (и даже после неё) признают в программистком программистском сообществе — функция ```atoi``` присутствует в C ещё со времён Кернигана и Ритчи, и переписывали её столько людей и столько раз, что ничего нового и оригинального, включая вашу никому не нужную обработку переполнения, вы точно не изобрели.

Больше того, функция ```atoi``` как стандартная находится в предсмертном состоянии. Она уже объявлена deprecated и будет удалена из будущих версий ISO/IEC 9899.

Но пока она ещё трепыхается, создавая видимость своей полезности (при том, что ```strtol``` и стала последним гвоздём в крышку гроба ```atoi```), и нас заставляют её реализовывать, то и вести она себя должна как стандартная (только не в вашем, а в правильном понимании смысла этого слова) — соответствуя требованиям стандарта ISO/IEC 9899. А требований там всего ничего:
* The `atoi` function converts the initial portion of the string pointed to by nptr to int.
* If the value of the result cannot be represented, the behavior is undefined.
* The function `atoi`needs not affect the value of the integer expression `errno` on an error.

Именно из-за последнего пункта этого списка рабочей группой WG14 Комитета по стандартизации и было принято решение “убить” `atoi` — у этой функции нет механизмов уведомить вызывающую об ошибке преобразования. Вызывающий не знает, успешным было это преобразование или нет. То ли там вообще не было символов, характерных для любого представления целочисленных типов, то ли их там было столько, что результат не влезет в `int`. Это и есть та самое undefined behavior, которое вы зачем-то пытаетесь to define и навязываете другим надуманную необходимость его to implement. Результат функции, которая оказалась в ситуации, описанной стандартом как undefined behavior, точно так же undefined *(читай “любой”)*, не годится даже на помойку, и может быть только проигнорирован. Кому какая разница, **что** именно игнорировать — 0, -1 или 100500100500?

Критерием правильности реализации `atoi` (и любой другой функции из перечисленных в Стандарте) может быть только соответствие этой функции требованиям ISO/IEC 9899, а никак не ваша убеждённость в том, что именно на вашем компьютере в школе и находится единственно верная реализация. Это не так — посмотрите ещё раз на скриншоты в начале топика.

Спасибо удачи всем, кто осилил и понял простыню :) Let's do a nice code we are born for...
